<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>modelize.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#addCustomCSS">addCustomCSS</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#addRecordType">addRecordType</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#addView">addView</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#baseConfig">baseConfig</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#catchLinksFromContent">catchLinksFromContent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#colors">colors</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#config">config</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#convertLinks">convertLinks</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#cosmoscope">cosmoscope</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#errors">errors</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#findFileMeta">findFileMeta</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#genMdFile">genMdFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getConnectedIds">getConnectedIds</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getConnectionLevels">getConnectionLevels</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getLinkStyle">getLinkStyle</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getRank">getRank</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#modifyExportPath">modifyExportPath</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#modifyImportPath">modifyImportPath</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#normalizeLink">normalizeLink</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#puslishModeIsActive">puslishModeIsActive</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#registerLinks">registerLinks</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#registerNodes">registerNodes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#registerTags">registerTags</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#registerType">registerType</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#show">show</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">modelize.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const fs = require('fs')
    , yamlFrontmatter = require('yaml-front-matter')
    , moment = require('moment')
    , path = require('path')
    , linksTools = require('./links')
    , logTools = require('./log')
    , historyPath = require('./history').historyPath
    , config = require('./verifconfig').config;

config.record_types_list = Object.keys(config.record_types);
config.link_types_list = Object.keys(config.link_types);

let fileIds = []
    , logs = { warn: [], err: [] }
    , entities = { nodes: [], links: [] }
    , id = 0;

let files = fs.readdirSync(config.files_origin, 'utf8') // files name list
    .filter(fileName => path.extname(fileName) === '.md') // throw no .md file
    .map(function(file) { // file analysis
        const mTime = fs.statSync(config.files_origin + file).mtime; // last modif date
        const fileName = file;

        file = fs.readFileSync(config.files_origin + file, 'utf8')
        // YAML Front Matter extract = file metas + file content
        file = yamlFrontmatter.loadFront(file);
        // file content extract
        let content = file.__content;
        delete file.__content;
        // file metas extract
        let metas = file;

        metas.mtime = moment(mTime).format('YYYY-MM-DD');
        metas.fileName = fileName;

        return {
            content: content,
            metas: metas
        }
    })
    .filter(function(file) { // throw files with bad metas
        if (!file.metas.id || isNaN(file.metas.id) === true) {
            logs.err.push(`File ${file.metas.fileName} throw out : no valid id`);
            return false; }

        if (!file.metas.title) {
            logs.err.push(`File ${file.metas.fileName} throw out : no valid title`);
            return false; }

        if (fileIds.includes(file.metas.id)) {
            logs.err.push(`File ${file.metas.fileName} throw out : uses an identifier common to another file`); }

        fileIds.push(file.metas.id);

        return true;
    })
    .map(function(file) { // normalize metas
        // null or no registered types changed to "undefined"
        if (file.metas.type === null || config.record_types_list.indexOf(file.metas.type) === -1) {
            file.metas.type = 'undefined';
            logs.warn.push(`Type of file ${file.metas.fileName} changed to undefined : no registered type`);
        }

        file.metas.tags = file.metas.tags || [];

        // analysis file content by regex : get links target id
        file.links = linksTools.catchLinksFromContent(file.content)
            .filter(function(link) {
                // throw links that are not numbers or from/to an unknown file id
                if (fileIds.includes(link.target.id) === false || isNaN(link.target.id) !== false) {
                    logs.warn.push(`The link "${link.target.id}" from file ${file.metas.fileName} has been ignored : no valid target`);
                    return false;
                }
                // change link type if is not registred into configuration. Exception for 'undefined' type
                if (config.link_types_list.includes(link.type) === false &amp;&amp; link.type !== 'undefined') {
                    logs.warn.push(`The link "${link.target.id}" type "${link.type}" from file ${file.metas.fileName} has been ignored : no registered type`);
                }

                return true;
            }).map(function(link) {
                link.source = { id: file.metas.id };
                return link
            });

        registerLinks(file);

        return file;
    });

// save &amp; show : errors &amp; warnings
logTools.show(logs);
logTools.register(logs, historyPath);

files = files.map(function(file) {

    file.links = file.links.map(function(link) {
        const targetMetas = findFileMeta(link.target.id);
        return {
            type: link.type,
            context: link.context,
            target: {
                id: link.target.id,
                title: targetMetas.title,
                type: targetMetas.type
            },
            source: {
                id: link.source.id,
                title: file.metas.title,
                type: file.metas.type
            }
        };
    });

    file.backlinks = entities.links.filter(link => link.target === file.metas.id)
        .map(function(link) {
            const targetMetas = findFileMeta(link.source);
            return {
                type: link.type,
                context: link.context,
                target: {
                    id: link.source,
                    title: targetMetas.title,
                    type: targetMetas.type
                },
                source: {
                    id: link.target,
                    title: file.metas.title,
                    type: file.metas.type
                }
            };
        });

    file.focusLevels = ((config.focus_max &lt;= 0) ? undefined : getConnectionLevels(file.metas.id, config.focus_max));

    registerNodes(file);

    return file;
});

entities.links = entities.links.map(function(link) {
    delete link.context; return link;
});

// generate the Cosmoscope
require('./template').cosmoscope(files, entities, historyPath);

if (historyPath) {
    // generate data files
    fs.writeFile(historyPath + 'data/nodes.json', JSON.stringify(entities.nodes), (err) => {
        if (err) {console.error('\x1b[31m', 'Err.', '\x1b[0m', 'write nodes.json file : ' + err) } });
    fs.writeFile(historyPath + 'data/links.json', JSON.stringify(entities.links), (err) => {
        if (err) {console.error('\x1b[31m', 'Err.', '\x1b[0m', 'write links.json file : ' + err) } });
}

/**
 * Feed entities.edges object with link object
 * @param {object} file - File after links parsing
 */

function registerLinks(file) {
    if (file.links.length === 0) { return; }

    for (const link of file.links) {
        const style = getLinkStyle(link.type);

        entities.links.push({
            id: Number(id++),
            type: link.type,
            shape: style.shape,
            color: style.color,
            source: Number(link.source.id),
            target: Number(link.target.id),
            context: link.context
        });
    }
}

/**
 * Feed entities.nodes object with node object
 * @param {object} file - File after links &amp; backlinks crop
 */

function registerNodes(file) {
    const size = linksTools.getRank(file.links.length, file.backlinks.length);

    entities.nodes.push({
        id: Number(file.metas.id),
        label: file.metas.title,
        type: String(file.metas.type),
        size: Number(size),
        outLink: Number(file.links.length),
        inLink: Number(file.backlinks.length),
        focus: file.focusLevels,
        hidden: false,
        isolated: false,
        highlighted: false
    });
}

/**
 * Find file metas by its id
 * @param {int} fileId - File after links &amp; backlinks parsing
 * @returns {array} - List of metas
 */

function findFileMeta(fileId) {
    return title = files.find(function(file) {
        return file.metas.id === fileId;
    }).metas;
}

/**
 * Get link stroke and color according to the type config
 * @param {string} linkType - Link type extract from his registration
 * @returns {object} - Shape and color paramters
 */

function getLinkStyle(linkType) {
    const linkTypeConfig = config.link_types[linkType];
    let stroke, color;

    if (linkTypeConfig) {
        stroke = config.link_types[linkType].stroke;
        color = config.link_types[linkType].color;
    } else {
        stroke = 'simple';
        color = null;
    }

    switch (stroke) {
        case 'simple':
            return { shape: { stroke: stroke, dashInterval: null }, color: color };
            
        case 'double':
            return { shape: { stroke: stroke, dashInterval: null }, color: color };

        case 'dash':
            return { shape: { stroke: stroke, dashInterval: '4, 5' }, color: color };

        case 'dotted':
            return { shape: { stroke: stroke, dashInterval: '1, 3' }, color: color };
    }

    return { shape: { stroke: 'simple', dashInterval: null }, color: color };
}

/**
 * Find nodes connected around a single one on several levels
 * Get data 'focus mode'
 * @param {number} nodeId - File id
 * @returns {array} - Array of arrays : contain one array per connection level
 */

function getConnectionLevels(nodeId, maxLevel) {

    let index = [[nodeId]]; // add the node as first level
    let idsList = []; // contains all handled node ids

    for (let i = 0 ; i &lt; maxLevel ; i++) {

        let level = [];
        
        // searching connections for each nodes from the last registred level
        for (const target of index[index.length - 1]) {
            let result = getConnectedIds(target);
            if (result === false) { continue; } // node have not connections, analyse next one

            // throw ids already registered into an other level toavoid infinit loop
            result = result.filter(target => idsList.includes(target) === false);

            level = level.concat(result);
        }

        // stop : current level contain any connection. There is no more level
        if (level.length === 0) { break; }

        // ignore duplicated ids
        level = level.filter((item, index) => {
            return level.indexOf(item) === index
        });

        index.push(level);
        idsList = index.flat();
    }

    return index.slice(1);
}

/**
 * Get connected links &amp; backlinks from a node
 * @param {int} nodeId - File id
 * @returns {array} - Links and backlinks ids list
 */

function getConnectedIds(nodeId) {
    const links = entities.links;

    let sources = links.filter(edge => edge.source === nodeId).map(edge => edge.target);
    let targets = links.filter(edge => edge.target === nodeId).map(edge => edge.source);

    targets = targets.concat(sources);

    if (targets.length === 0) {
        return false; }

    return targets;
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Mon Jun 07 2021 14:43:34 GMT+0200 (heure d’été d’Europe centrale) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
